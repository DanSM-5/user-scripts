#!/usr/bin/env bash

# Default mode
mode='log'
open=false
editor="${PREFERRED_EDITOR:-${EDITOR:-vim}}"
history_location="${FZF_HIST_DIR:-$HOME/.cache/fzf-history}"
history_file="$history_location/git-search-commits"

showHelp () {
  printf "%s\n" "
    Git search in commits or patches

    Description:
      Select a mode for search and interactively search in the logs or the patches
      of the commits. Fzf have two modes, git search (initial) and fuzzy filter to
      narrow on the remaining items available.

    Usage:
      Call \`git-search-commits\` to start interactive search on fzf.

    Dependencies:
      - git
      - fzf
      - delta (optional)

      Optional for one of the below (linux only)
      - wl-copy
      - xclip
      - xsel

    Flags:

      -h, --help                   > Print this message.

      -l, --log                    > Search in the log of the commits.

      -s, --string                 > Search in the patches of commits by exact match.

      -r, --regex                  > Search in the patches of commits by regex.

      -m, --mode                   > Set the mode with a string instead of a boolean flag.

      -e, --edit                   > Open the selected commits in your editor (\$EDITOR).

    Arguments:

      Remaining arguments are treated as the initial query for search.
  "
}


# Allow complex regex globs
shopt -s extglob

# Args parsing
# Ref: https://stackoverflow.com/a/14203146
while [[ $# -gt 0 ]]; do
  case $1 in
    -[lL]|-?(-)[lL]og)
      mode='log'
      shift # past argument
      ;;
    -[rR]|-?(-)[rR]egex)
      mode='regex'
      shift # past argument
      ;;
    -[sS]|-?(-)[sS]tring)
      mode='string'
      shift # past argument
      ;;
    -[mM]|-?(-)[mM]ode)
      mode="$2"
      shift # past argument
      shift # past value
      ;;
    -[eE]|-?(-)[eE]edit)
      open=true
      shift # past argument
      ;;
    -[hH]|-?(-)[hH]elp)
      showHelp
      exit 0
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      # POSITIONAL_ARGS+=("$1") # save positional arg
      POSITIONAL_ARGS+=("$1") # Positional args are considered urls to download
      shift # past argument
      ;;
  esac
done

# Restore positional arguments
set -- "${POSITIONAL_ARGS[@]}"

# Git command to perform
base_command=''
if [ "$mode" = 'regex' ]; then
  base_command='git log --color=always --oneline --branches --all -G %s 2>/dev/null'
elif [ "$mode" = 'string' ]; then
  base_command='git log --color=always --oneline --branches --all -S %s 2>/dev/null'
else
  mode='log'
  base_command='git log --color=always --oneline --branches --all --grep %s 2>/dev/null'
fi

source_command="$(printf "$base_command" "'$*'")"
reload_command="$(printf "$base_command" '{q}') || true"

# Setup preview
fzf_preview='git show --color=always {1} '
if command -v delta &>/dev/null; then
  fzf_preview="$fzf_preview | delta || true"
else
  fzf_preview="$fzf_preview || true"
fi

# Ensure history location exists
mkdir -p "$history_location"

# Find clipboard utility
copy='true'
if [[ "$(uname)" =~ MINGW.*|MSYS.*|CYGWIN.*|.*NT.* ]]; then
  # Gitbash
  copy="cat '{+f}' | awk '{ print \$1 }' | clip.exe"
elif [ "$OSTYPE" = 'darwin' ]; then
  copy="cat {+f} | awk '{ print \$1 }'| pbcopy"
# Assume linux if above didn't match
elif [ -n "$WAYLAND_DISPLAY" ] && command -v 'wl-copy' &>/dev/null; then
  copy="cat {+f} | awk '{ print \$1 }'| wl-copy --foreground --type text/plain"
elif [ -n "$DISPLAY" ] && command -v 'xsel' &>/dev/null; then
  copy="cat {+f} | awk '{ print \$1 }' | xsel -i -b"
elif [ -n "$DISPLAY" ] && command -v 'xclip' &>/dev/null; then
  copy="cat {+f} | awk '{ print \$1 }'| xclip -i -selection clipboard"
fi

# It may be useful but prefer the initil pipe for now
# --bind "start:reload:$source_command"

# Call fzf
commits=($(eval "$source_command" |
  fzf \
  --history="$history_file" \
  --height 80% --min-height 20 --border \
  --info=inline \
  --bind 'ctrl-/:change-preview-window(down|hidden|)' \
  --bind 'ctrl-^:toggle-preview' \
  --bind 'alt-up:preview-page-up,alt-down:preview-page-down' \
  --bind 'shift-up:preview-up,shift-down:preview-down' \
  --bind 'ctrl-s:toggle-sort' \
  --bind 'alt-a:select-all' \
  --bind 'alt-d:deselect-all' \
  --bind 'alt-f:first' \
  --bind 'alt-l:last' \
  --bind 'alt-c:clear-query' \
  --prompt 'GitSearch> ' \
  --header "Mode: $mode | ctrl-r: Interactive search | ctrl-f: Filtering results | ctrl-y: Copy hashes" \
  --multi --ansi \
  --layout=reverse \
  --disabled \
  --query "$*" \
  --bind "ctrl-y:execute-silent:$copy" \
  --bind "ctrl-r:unbind(ctrl-r)+change-prompt(GitSearch> )+disable-search+reload($reload_command)+rebind(change,ctrl-f)" \
  --bind "ctrl-f:unbind(change,ctrl-f)+change-prompt(FzfFilter> )+enable-search+clear-query+rebind(ctrl-r)" \
  --bind "change:reload:$reload_command" \
  --preview "$fzf_preview" |
  awk '{ print $1 }'))

# If no commits, exit
if [ -z "${commits[*]}" ]; then
  exit
fi

# Show selected commits
if [ "$open" = false ]; then
  git show "${commits[@]}"
  exit
fi

# Open in editor
tmpfile="$(mktemp)"
git show "${commits[@]}" > "$tmpfile"

# On (n)vim editor set filetype
if [[ "$editor" =~ ^n?vim?$ ]]; then
  exec "$editor" -c ":filetype detect" "$tmpfile"
else
  exec "$editor" "$tmpfile"
fi

